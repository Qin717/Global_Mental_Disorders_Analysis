<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mental Disorders Analysis - Network Visualization</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #4f81bd 0%, #70ad47 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }
        
        .header h1 {
            margin: 0;
            font-size: 2.5em;
            font-weight: 300;
        }
        
        .header p {
            margin: 10px 0 0 0;
            font-size: 1.2em;
            opacity: 0.9;
        }
        
        .dashboard {
            padding: 30px;
        }
        
        .chart-container {
            margin-bottom: 40px;
            background: #f8f9fa;
            border-radius: 10px;
            padding: 25px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.08);
        }
        
        .chart-title {
            font-size: 1.5em;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        
        .controls {
            margin-bottom: 20px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .control-group label {
            font-weight: 600;
            color: #555;
            font-size: 0.9em;
        }
        
        select, input, button {
            padding: 8px 12px;
            border: 2px solid #ddd;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        
        select:focus, input:focus {
            outline: none;
            border-color: #3498db;
        }
        
        button {
            background: #3498db;
            color: white;
            border: none;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        button:hover {
            background: #2980b9;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
            z-index: 1000;
            box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        }
        
        .tooltip h4 {
            margin: 0 0 5px 0;
            color: #3498db;
        }
        
        .tooltip p {
            margin: 2px 0;
        }
        
        .node {
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .node:hover {
            stroke: #333;
            stroke-width: 3;
        }
        
        .node-label {
            font-size: 10px;
            text-anchor: middle;
            pointer-events: none;
            fill: white;
            font-weight: bold;
        }
        
        .link {
            stroke: #999;
            stroke-opacity: 0.6;
            stroke-width: 1;
            transition: all 0.3s ease;
        }
        
        .link:hover {
            stroke-opacity: 1;
            stroke-width: 3;
        }
        
        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }
        
        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-top: 15px;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        
        .stat-card {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 5px 15px rgba(0,0,0,0.1);
        }
        
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Mental Disorders Analysis</h1>
            <p>Interactive Network Visualization: Countries & Disorders</p>
        </div>
        
        <div class="dashboard">
            <div class="stats-grid" id="statsGrid">
                <div class="stat-card">
                    <div class="stat-value" id="totalCountries">-</div>
                    <div class="stat-label">Countries Analyzed</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="totalDisorders">-</div>
                    <div class="stat-label">Mental Disorders</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="avgPrevalence">-</div>
                    <div class="stat-label">Average Prevalence (%)</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="highestPrevalence">-</div>
                    <div class="stat-label">Highest Prevalence (%)</div>
                </div>
            </div>
            
            <!-- Chart 1: Interactive Network Diagram -->
            <div class="chart-container">
                <h2 class="chart-title">Interactive Network: Countries & Mental Disorders</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="networkDisorderSelect">Filter by Disorder:</label>
                        <select id="networkDisorderSelect">
                            <option value="all">All Disorders</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label for="networkThreshold">Minimum Prevalence:</label>
                        <input type="number" id="networkThreshold" value="2.0" min="0.1" max="5.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="networkNodeCount">Max Countries:</label>
                        <input type="number" id="networkNodeCount" value="15" min="5" max="30">
                    </div>
                    <div class="control-group">
                        <button id="resetNetwork">Reset Layout</button>
                    </div>
                </div>
                <div id="networkChart"></div>
            </div>
            
            <!-- Chart 2: Chord Diagram -->
            <div class="chart-container">
                <h2 class="chart-title">Chord Diagram: Disorder Relationships</h2>
                <div class="controls">
                    <div class="control-group">
                        <label for="chordThreshold">Minimum Prevalence:</label>
                        <input type="number" id="chordThreshold" value="1.5" min="0.1" max="5.0" step="0.1">
                    </div>
                    <div class="control-group">
                        <label for="chordMaxDisorders">Max Disorders:</label>
                        <input type="number" id="chordMaxDisorders" value="6" min="3" max="10">
                    </div>
                </div>
                <div id="chordChart"></div>
            </div>
        </div>
    </div>
    
    <div class="tooltip" id="tooltip"></div>
    
    <script>
        // Global variables
        let countryData = [];
        let ageData = [];
        let allData = [];
        
        // Color schemes
        const colorSchemes = {
            disorders: d3.scaleOrdinal(d3.schemeCategory10),
            countries: d3.scaleOrdinal(d3.schemeSet3)
        };
        
        // Dimensions
        const dimensions = {
            networkChart: { width: 1000, height: 600, margin: { top: 20, right: 20, bottom: 20, left: 20 } },
            chordChart: { width: 800, height: 600, margin: { top: 20, right: 20, bottom: 20, left: 20 } }
        };
        
        // Tooltip
        const tooltip = d3.select("#tooltip");
        
        // Load data
        async function loadData() {
            try {
                console.log('Starting data load...');
                
                // Load country data
                const countryResponse = await fetch('Q4_country_data.csv');
                if (!countryResponse.ok) {
                    throw new Error(`Failed to load country data: ${countryResponse.status} ${countryResponse.statusText}`);
                }
                const countryText = await countryResponse.text();
                countryData = d3.csvParse(countryText, d3.autoType);
                console.log('Country data parsed, records:', countryData.length);
                
                // Load age data
                const ageResponse = await fetch('Q4_age_data.csv');
                if (!ageResponse.ok) {
                    throw new Error(`Failed to load age data: ${ageResponse.status} ${ageResponse.statusText}`);
                }
                const ageText = await ageResponse.text();
                ageData = d3.csvParse(ageText, d3.autoType);
                console.log('Age data parsed, records:', ageData.length);
                
                // Combine all data
                allData = [...countryData, ...ageData];
                console.log('Total combined records:', allData.length);
                
                // Update statistics
                updateStatistics();
                
                // Populate select options
                populateSelects();
                
                // Create visualizations
                console.log('Creating visualizations...');
                createNetworkChart();
                createChordChart();
                
                console.log('All visualizations created successfully!');
                
            } catch (error) {
                console.error('Error loading data:', error);
                document.querySelector('.dashboard').innerHTML = 
                    `<div class="loading" style="color: red; background: #ffe6e6; padding: 20px; border-radius: 5px;">
                        <h3>Error Loading Data</h3>
                        <p><strong>Error:</strong> ${error.message}</p>
                        <p><strong>Make sure you're running a local server:</strong></p>
                        <code>cd /Users/qinqin/Desktop/Mental_Disorders/reports && python3 -m http.server 8001</code><br/>
                        <code>Then open: http://localhost:8001/Q4_network_visualization.html</code>
                    </div>`;
            }
        }
        
        function updateStatistics() {
            const uniqueCountries = new Set(countryData.map(d => d.country)).size;
            const uniqueDisorders = new Set(allData.map(d => d.disorder)).size;
            const avgPrevalence = d3.mean(allData, d => d.avg_prevalence_percent);
            const maxPrevalence = d3.max(allData, d => d.avg_prevalence_percent);
            
            document.getElementById('totalCountries').textContent = uniqueCountries;
            document.getElementById('totalDisorders').textContent = uniqueDisorders;
            document.getElementById('avgPrevalence').textContent = avgPrevalence.toFixed(2);
            document.getElementById('highestPrevalence').textContent = maxPrevalence.toFixed(2);
        }
        
        function populateSelects() {
            const disorders = [...new Set(allData.map(d => d.disorder))].sort();
            
            const networkDisorderSelect = d3.select('#networkDisorderSelect');
            
            networkDisorderSelect.selectAll('option')
                .data(['all', ...disorders])
                .enter()
                .append('option')
                .attr('value', d => d)
                .text(d => d === 'all' ? 'All Disorders' : d);
        }
        
        function createNetworkChart() {
            console.log('Creating network chart...');
            const container = d3.select('#networkChart');
            container.selectAll('*').remove();
            
            const svg = container.append('svg')
                .attr('width', dimensions.networkChart.width)
                .attr('height', dimensions.networkChart.height);
            
            const width = dimensions.networkChart.width - dimensions.networkChart.margin.left - dimensions.networkChart.margin.right;
            const height = dimensions.networkChart.height - dimensions.networkChart.margin.top - dimensions.networkChart.margin.bottom;
            
            const g = svg.append('g')
                .attr('transform', `translate(${dimensions.networkChart.margin.left},${dimensions.networkChart.margin.top})`);
            
            // Get filtered data
            const selectedDisorder = document.getElementById('networkDisorderSelect').value;
            const threshold = parseFloat(document.getElementById('networkThreshold').value);
            const nodeCount = parseInt(document.getElementById('networkNodeCount').value);
            
            let filteredData = countryData;
            if (selectedDisorder !== 'all') {
                filteredData = countryData.filter(d => d.disorder === selectedDisorder);
            }
            
            // Filter by threshold
            filteredData = filteredData.filter(d => d.avg_prevalence_percent >= threshold);
            
            // Get top countries
            const topCountries = [...new Set(filteredData.map(d => d.country))]
                .map(country => ({
                    country,
                    avgPrevalence: d3.mean(filteredData.filter(d => d.country === country), d => d.avg_prevalence_percent),
                    disorders: filteredData.filter(d => d.country === country).map(d => d.disorder)
                }))
                .sort((a, b) => b.avgPrevalence - a.avgPrevalence)
                .slice(0, nodeCount);
            
            // Create nodes and links
            const nodes = [
                ...topCountries.map(c => ({ id: c.country, type: 'country', prevalence: c.avgPrevalence })),
                ...([...new Set(filteredData.map(d => d.disorder))].map(d => ({ id: d, type: 'disorder' })))
            ];
            
            const links = filteredData
                .filter(d => topCountries.some(c => c.country === d.country))
                .map(d => ({
                    source: d.country,
                    target: d.disorder,
                    value: d.avg_prevalence_percent
                }));
            
            console.log('Network nodes:', nodes.length, 'links:', links.length);
            
            // Create force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(100))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(30));
            
            // Color scale
            const colorScale = d3.scaleOrdinal()
                .domain([...new Set(filteredData.map(d => d.disorder))])
                .range(d3.schemeCategory10);
            
            // Size scale for nodes
            const sizeScale = d3.scaleSqrt()
                .domain(d3.extent(nodes.filter(n => n.type === 'country'), d => d.prevalence))
                .range([8, 25]);
            
            // Create links
            const linkGroup = g.append('g').attr('class', 'links');
            
            linkGroup.selectAll('.link')
                .data(links)
                .enter()
                .append('line')
                .attr('class', 'link')
                .attr('stroke', d => colorScale(d.target))
                .attr('stroke-width', d => Math.max(1, d.value / 3))
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .html(`
                            <h4>${d.source} → ${d.target}</h4>
                            <p><strong>Prevalence:</strong> ${d.value.toFixed(2)}%</p>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            // Create nodes
            const nodeGroup = g.append('g').attr('class', 'nodes');
            
            const nodeElements = nodeGroup.selectAll('.node')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', 'node')
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));
            
            nodeElements.append('circle')
                .attr('r', d => d.type === 'country' ? sizeScale(d.prevalence) : 15)
                .attr('fill', d => d.type === 'country' ? '#3498db' : colorScale(d.id))
                .attr('opacity', 0.8)
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .html(`
                            <h4>${d.id}</h4>
                            <p><strong>Type:</strong> ${d.type}</p>
                            ${d.prevalence ? `<p><strong>Prevalence:</strong> ${d.prevalence.toFixed(2)}%</p>` : ''}
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            // Add labels
            nodeElements.append('text')
                .attr('class', 'node-label')
                .attr('dy', '0.35em')
                .text(d => d.id.length > 8 ? d.id.substring(0, 8) + '...' : d.id)
                .style('font-size', d => d.type === 'country' ? '10px' : '9px');
            
            // Update positions on simulation tick
            simulation.on('tick', () => {
                linkGroup.selectAll('.link')
                    .attr('x1', d => d.source.x)
                    .attr('y1', d => d.source.y)
                    .attr('x2', d => d.target.x)
                    .attr('y2', d => d.target.y);
                
                nodeElements.attr('transform', d => `translate(${d.x},${d.y})`);
            });
            
            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }
            
            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }
            
            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
            
            // Store simulation for reset
            window.networkSimulation = simulation;
        }
        
        function createChordChart() {
            console.log('Creating chord chart...');
            const container = d3.select('#chordChart');
            container.selectAll('*').remove();
            
            const svg = container.append('svg')
                .attr('width', dimensions.chordChart.width)
                .attr('height', dimensions.chordChart.height);
            
            const width = dimensions.chordChart.width - dimensions.chordChart.margin.left - dimensions.chordChart.margin.right;
            const height = dimensions.chordChart.height - dimensions.chordChart.margin.top - dimensions.chordChart.margin.bottom;
            
            const g = svg.append('g')
                .attr('transform', `translate(${dimensions.chordChart.margin.left + width/2},${dimensions.chordChart.margin.top + height/2})`);
            
            // Get filtered data
            const threshold = parseFloat(document.getElementById('chordThreshold').value);
            const maxDisorders = parseInt(document.getElementById('chordMaxDisorders').value);
            
            // Get top disorders by average prevalence
            const disorderAverages = [...new Set(countryData.map(d => d.disorder))]
                .map(disorder => ({
                    disorder,
                    avgPrevalence: d3.mean(countryData.filter(d => d.disorder === disorder), d => d.avg_prevalence_percent)
                }))
                .sort((a, b) => b.avgPrevalence - a.avgPrevalence)
                .slice(0, maxDisorders);
            
            const topDisorders = disorderAverages.map(d => d.disorder);
            
            // Create matrix for chord diagram
            const matrix = [];
            const n = topDisorders.length;
            
            for (let i = 0; i < n; i++) {
                matrix[i] = [];
                for (let j = 0; j < n; j++) {
                    if (i === j) {
                        // Self-connection (prevalence within disorder)
                        matrix[i][j] = disorderAverages[i].avgPrevalence;
                    } else {
                        // Cross-connections (countries with both disorders)
                        const countriesWithI = new Set(countryData.filter(d => d.disorder === topDisorders[i] && d.avg_prevalence_percent >= threshold).map(d => d.country));
                        const countriesWithJ = new Set(countryData.filter(d => d.disorder === topDisorders[j] && d.avg_prevalence_percent >= threshold).map(d => d.country));
                        const intersection = new Set([...countriesWithI].filter(x => countriesWithJ.has(x)));
                        matrix[i][j] = intersection.size * 0.1; // Scale down for visualization
                    }
                }
            }
            
            console.log('Chord matrix created:', matrix.length, 'x', matrix[0].length);
            
            // Create chord layout
            const chord = d3.chord()
                .padAngle(0.05)
                .sortSubgroups(d3.descending);
            
            const chords = chord(matrix);
            
            // Color scale
            const colorScale = d3.scaleOrdinal()
                .domain(topDisorders)
                .range(d3.schemeCategory10);
            
            // Create chord groups
            const group = g.append('g').attr('class', 'groups');
            
            group.selectAll('.group')
                .data(chords.groups)
                .enter()
                .append('path')
                .attr('class', 'group')
                .attr('d', d3.arc()
                    .innerRadius(150)
                    .outerRadius(180))
                .attr('fill', d => colorScale(topDisorders[d.index]))
                .attr('opacity', 0.8)
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .html(`
                            <h4>${topDisorders[d.index]}</h4>
                            <p><strong>Average Prevalence:</strong> ${disorderAverages[d.index].avgPrevalence.toFixed(2)}%</p>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            // Create chord ribbons
            const ribbon = g.append('g').attr('class', 'ribbons');
            
            ribbon.selectAll('.ribbon')
                .data(chords)
                .enter()
                .append('path')
                .attr('class', 'ribbon')
                .attr('d', d3.ribbon()
                    .radius(150))
                .attr('fill', d => colorScale(topDisorders[d.source.index]))
                .attr('opacity', 0.6)
                .on('mouseover', function(event, d) {
                    tooltip.style('opacity', 1)
                        .html(`
                            <h4>${topDisorders[d.source.index]} ↔ ${topDisorders[d.target.index]}</h4>
                            <p><strong>Connection Strength:</strong> ${d.source.value.toFixed(2)}</p>
                        `)
                        .style('left', (event.pageX + 10) + 'px')
                        .style('top', (event.pageY - 10) + 'px');
                })
                .on('mouseout', function() {
                    tooltip.style('opacity', 0);
                });
            
            // Add labels
            group.selectAll('.group-label')
                .data(chords.groups)
                .enter()
                .append('text')
                .attr('class', 'group-label')
                .attr('transform', d => {
                    const angle = (d.startAngle + d.endAngle) / 2;
                    const x = Math.cos(angle - Math.PI / 2) * 200;
                    const y = Math.sin(angle - Math.PI / 2) * 200;
                    return `translate(${x}, ${y}) rotate(${angle * 180 / Math.PI})`;
                })
                .attr('text-anchor', d => (d.startAngle + d.endAngle) / 2 > Math.PI ? 'end' : 'start')
                .text(d => topDisorders[d.index].length > 12 ? topDisorders[d.index].substring(0, 12) + '...' : topDisorders[d.index])
                .style('font-size', '11px')
                .style('font-weight', 'bold');
        }
        
        // Event listeners
        document.getElementById('networkDisorderSelect').addEventListener('change', createNetworkChart);
        document.getElementById('networkThreshold').addEventListener('input', createNetworkChart);
        document.getElementById('networkNodeCount').addEventListener('change', createNetworkChart);
        document.getElementById('resetNetwork').addEventListener('click', () => {
            if (window.networkSimulation) {
                window.networkSimulation.alpha(0.3).restart();
            }
        });
        
        document.getElementById('chordThreshold').addEventListener('input', createChordChart);
        document.getElementById('chordMaxDisorders').addEventListener('change', createChordChart);
        
        // Initialize
        loadData();
    </script>
</body>
</html>
